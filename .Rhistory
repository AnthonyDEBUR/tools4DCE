ddatawd <- paste0(datawd,"/report2.3/data/")
#imgwd <- "C:/workspace/EDAdata/reportt2.3/images/"
#edawd =  "C:/workspace/EDA/"
sanitizeLatexS <- function(str) {
gsub('([#$%&~_\\^\\\\{}])', '\\\\\\\\\\1', str, perl = TRUE);
}
# la fonction sn utilise maintenant le package siunitx
# ajouter \usepackage{siunitx}
#\sisetup{
#round-mode = places, % nombre de decimales apres la virgule
#round-precision = 3
#}%
# Dans le preambule
num <- function(x,round_precision =  NULL)
{
if (is.null(round_precision)) {
return(sprintf("\\num{%s}", x))
} else {
return(sprintf("\\num[round-precision=%s]{%s}",round_precision+1, x))
}
}
wd <- getwd()
# choix de la version a charger
rapport <- "2020" #"2012" "2015" "2009"
sector <- "spain"
open_in_excel <- function(some_df){
tFile <- paste("C:/temp/",gsub("\\\\","",tempfile(fileext =  paste0(substitute(some_df), ".csv"),tmpdir =  "")),sep =  "")
write.table(some_df, tFile, row.names = F, sep = ";", quote = F)
system(paste('open -a \"/ProgramData/Microsoft/Windows/Start Menu/Programs/Microsoft Office/Microsoft Excel 2010\"', tFile))
}
library(readxl)
library(sf)
library(scam)
# vvv <- list()
# save(vvv, file=paste0(ddatawd,"vvv.Rdata"))
dam_rios_frsppt <- new("BaseEdaRiosRiversegmentsDam",
baseODBC = "baseODBCrios", # must be set in init length 1
schema = "dbeel_rivers",
table = "rn",
join_obstruction_rn_downstream= "dbeel_rivers.join_obstruction_rn_downstream",
joinschema = "sudoang",
jointable = "view_obstruction",
zonegeo = c("Spain","Portugal","France"),
basin=as.character(NULL),
prkey = "idsegment")
dam_rios_frsppt <- loaddb2(dam_rios_frsppt)
dam_rios_frsppt@datadam <- dam_rios_frsppt@datadam[,c("op_id",  "op_op_id", "id_original",
"obstruction_impact_code","obstruction_type_code","po_obstruction_height",
"po_presence_eel_pass",
"fishway_type_code", "fishway_type_name")]
#dam_rios_spain <- loadshp(dam_rios_spain)
save(dam_rios_frsppt, file=str_c(ddatawd,"dam_rios_frsppt.Rdata"))
dams <- dam_rios_frsppt@datadam # 20589
join_dam_rn <- sqldf("select * from dbeel_rivers.join_obstruction_rn") # 20606
dd <- dplyr::inner_join(join_dam_rn,dams, by="op_id") # 20589
rr <- dplyr::inner_join(dd,dam_rios_frsppt@data, by="idsegment") # 20589
rr<- rename(rr,"h"="po_obstruction_height")
save(rr,file=str_c(ddatawd,"rrfrsppt.Rdata"))
ddatawd <- paste0(datawd,"/report2.3/data/")
load(file=str_c(ddatawd,"rrp_spain_portugal.Rdata")) # ggl glm model
rrp_sppt <- rrp
head(rrp)
# see Dams.Rmd
load(file=str_c(ddatawd,"rrp.Rdata"))
load(file=str_c(ddatawd,"gg_glm_hauteur_obstacle.Rdata")) # gg glm model
load(file=str_c(ddatawd,"rr.Rdata"))
# recodage du jeu de données
rr$basinh <- gsub("]","",sapply(strsplit(rr$basin, "\\["), "[", 2))
rr$basinh<-substring(rr$basinh,1,1)
rr$obstruction_type_code <- replace(
rr$obstruction_type_code,
which(rr$obstruction_type_code=='OT'), # OTHER
"UN")
rr$pred <- predict(gg, newdata=rr)
rr$is_height_predicted<-FALSE
rr$is_height_predicted[is.na(rr$h)]<-TRUE #  28328
rr$hpred<-rr$h
rr$hpred[is.na(rr$h)] <- exp(rr$pred[is.na(rr$h)])
# note this will be loaded later in the class method BaseEdaRiosriversegmentsDam
rrp<-rr[,c("id_original","is_height_predicted","hpred")]
save(rrp, file=str_c(ddatawd,"rrp.Rdata"))
# see Dams.Rmd
load(file=str_c(ddatawd,"rrp.Rdata"))
rrp_fr <- rrp
rrp_fr[rrp_fr$id_original=='ROE45139',]
# remove height from downstream water course where dams may have been projected by error on the RHT
bdp<- sqldf("select * from sudoang.downstream_badly_projected")
bdp<- sqldf("select * from sudoang.downstream_badly_projected")
options(sqldf.RPostgreSQL.user = "postgres",
sqldf.RPostgreSQL.password = passwordlocal,
sqldf.RPostgreSQL.dbname = "eda2.3",
sqldf.RPostgreSQL.host = "localhost",#  1.100.1.6
sqldf.RPostgreSQL.port = 5432)
bdp<- sqldf("select * from sudoang.downstream_badly_projected")
rrp_fr[rrp_fr$id_original%in%bdp$id_original,'hpred']<-0
rrp_fr$country <- "FR"
rrp <- rbind(rrp_sppt, rrp_fr)
rm(rrp_fr,rrp_sppt)
dam_rios_frsppt <- cumulated_dam_impact2(object=dam_rios_frsppt, predicted_height=rrp)
require(knitr)
opts_knit$set(eval.after = 'fig.cap')
#options(error = browser())
# this will set figure caption to cap inside R chunk
obj <- ls(all=TRUE)
obj <- obj[!obj%in%c("passworddistant","passwordlocal")]
getUsername <- function(){
name <- Sys.info()[["user"]]
return(name)
}
#memory.limit(size =4000)
if(getUsername() == 'cedric.briand'|getUsername() == 'mmateo') setwd("C:/workspace/EDA/")
rivernetwork <- "RIOS"
source("EDACCM/init.r")
#citation("sqldf")
#citation("RPostgreSQL")
#citation("RColorBrewer")
#citation("plyr")
#citation("ggplot2")
#citation("stargazer")
#citation("visreg")
#citation("mgcv")
#citation("PresenceAbsence")
graphics.off()
#options(warn =  -1)
options(sqldf.RPostgreSQL.user = "postgres",
sqldf.RPostgreSQL.password = passwordlocal,
sqldf.RPostgreSQL.dbname = "eda2.3",
sqldf.RPostgreSQL.host = "localhost",#  1.100.1.6
sqldf.RPostgreSQL.port = 5432)
#t <- tryCatch(sqldf("select gid from rht.rhtvs2 limit 1"),error =  function(e) e)
#is_simple_error <- function(x) inherits(x, "simpleError")
#if (is_simple_error(t)) stop("distant call using w3.eptb-vilaine.fr failed, check connection to the database")
#baseODBCccm[1] <- "eda2"
#baseODBC[1] <- "ouvragelb"
#baseODBCdbeel[1] <- "dbeel"
#baseODBCrht[1] <- "eda2rht"
# Attention il faut creer les repertoires
options(warn =  0)
#setwd("C:/workspace/EDA/report2.3")
datawd <- "C:/workspace/EDAdata/"
ddatawd <- paste0(datawd,"/report2.3/data/")
#imgwd <- "C:/workspace/EDAdata/reportt2.3/images/"
#edawd =  "C:/workspace/EDA/"
sanitizeLatexS <- function(str) {
gsub('([#$%&~_\\^\\\\{}])', '\\\\\\\\\\1', str, perl = TRUE);
}
# la fonction sn utilise maintenant le package siunitx
# ajouter \usepackage{siunitx}
#\sisetup{
#round-mode = places, % nombre de decimales apres la virgule
#round-precision = 3
#}%
# Dans le preambule
num <- function(x,round_precision =  NULL)
{
if (is.null(round_precision)) {
return(sprintf("\\num{%s}", x))
} else {
return(sprintf("\\num[round-precision=%s]{%s}",round_precision+1, x))
}
}
wd <- getwd()
# choix de la version a charger
rapport <- "2020" #"2012" "2015" "2009"
sector <- "spain"
open_in_excel <- function(some_df){
tFile <- paste("C:/temp/",gsub("\\\\","",tempfile(fileext =  paste0(substitute(some_df), ".csv"),tmpdir =  "")),sep =  "")
write.table(some_df, tFile, row.names = F, sep = ";", quote = F)
system(paste('open -a \"/ProgramData/Microsoft/Windows/Start Menu/Programs/Microsoft Office/Microsoft Excel 2010\"', tFile))
}
library(readxl)
library(sf)
library(scam)
# vvv <- list()
# save(vvv, file=paste0(ddatawd,"vvv.Rdata"))
options(dplyr.summarise.inform=F)
ddatawd <- paste0(datawd,"/report2.3/data/")
# see DamsSPPT.Rmd
load(file=str_c(ddatawd,"rrp_spain_portugal.Rdata")) # ggl glm model
rrp_sppt <- rrp
# see Dams.Rmd
load(file=str_c(ddatawd,"rrp.Rdata"))
rrp_fr <- rrp
rrp_fr[rrp_fr$id_original=='ROE45139',]
# remove height from downstream water course where dams may have been projected by error on the main course
# uses dis_m3_pyr_riveratlas, to find obstructions with height null where dis_m3_pyr_riveratlas>150
bdp<- sqldf("select * from sudoang.downstream_badly_projected")
rrp_fr[rrp_fr$id_original%in%bdp$id_original,'hpred']<-0
rrp_fr$country <- "FR"
rrp <- rbind(rrp_sppt, rrp_fr)
rm(rrp_fr,rrp_sppt)
load(file = str_c(ddatawd,"dam_rios_frsppt.Rdata"))
dam_rios_frsppt <- cumulated_dam_impact2(object=dam_rios_frsppt, predicted_height=rrp)
save(dam_rios_frsppt,file=str_c(ddatawd,"dam_rios_frsppt.Rdata"))
dam_rios_frsppt_data <- dam_rios_frsppt@data
save(dam_rios_frsppt_data,file=str_c(ddatawd,"dam_rios_frsppt_data.Rdata"))
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(readxl)
library(RPostgreSQL)
ddatawd <- "C:/workspace/EDAdata/report2.3/data/"
ll <-list.files("F:/eda/data/eda2.3/modelisation_migration/")
ll <- ll[grep("extr",ll)]
for (name in ll){
load(file.path("F:/eda/data/eda2.3/modelisation_migration/", name))
}
if (class(data$date)[1]=="character") data$date <- lubridate::dmy(data$date)
# franchissement Gave de Pau
fg <- read_excel("F:/eda/data/eda2.3/modelisation_migration/debits_devalaison_gave_pau.xlsx", sheet="franch")
# debits classes periode etude
dcpe <- read_excel("F:/eda/data/eda2.3/modelisation_migration/debits_devalaison_gave_pau.xlsx",  sheet="debit_classe")
con=dbConnect(PostgreSQL(),
dbname="eda2.3",
host="localhost",
port=5432,
user= userlocal,
password= passwordlocal)
# Le Gave de Pau à Bérenx [Pont de Bérenx]
flow<- dbGetQuery(con,"SELECT * FROM  sudoang.hydro_station_gt2_quantile where code_hydro_station='Q5501010'")
# building a graph to compare migration
f1<- flow %>% select (starts_with("q_1004")) %>%
select(-c("q_1004_75","q_1004_975")) %>%
filter(row_number()==1)
d1 <- dcpe %>%
filter(Centile%in%c(10,20,30,40,50,60,70,80,90,95,99)) %>%
select(Q) %>% t()
colnames(d1) <- colnames(f1)
d2 <- rbind(d1, f1)
d2 <- cbind(d2, source= c("Q_1104_2006_2010","Q_1004_1923_2017"))
d3 <- d2 %>% pivot_longer(cols=-source,names_to='Qi', values_to='Q')
f2<- flow %>% select (starts_with("q_1004"))%>%filter(row_number()==1)
f1[1]<-0# first class is : 0 - Q20
fg$qcalss <- cut(fg$Qjournalier,c(f1%>%t()%>%as.vector(),10000),labels=c(colnames(f1)))
fg$qcalss <- as.integer(fg$qcalss)-1
save(fg, flow, dcpe, d3, file="C:/workspace/edadata/sudoang/data_gave_pau.Rdata")
require(knitr)
opts_knit$set(eval.after = 'fig.cap' ) # to be used in chunks used only to plot pictures
knitr::opts_chunk$set(fig.width=12, fig.height=8, echo=FALSE)
options(knitr.table.format = 'html') # options pour kable
options(knitr.kable.NA = '.')
# this will set figure caption to cap inside R chunk
obj <- ls(all=TRUE)
obj <- obj[!obj%in%c("passworddistant","passwordlocal")]
getUsername <- function(){
name <- Sys.info()[["user"]]
return(name)
}
#memory.limit(size =4000)
if(getUsername() == 'cedric.briand'|getUsername() == 'mmateo') setwd("C:/workspace/EDA/")
rivernetwork <- "RIOS"
source("EDACCM/init.r")
#citation("sqldf")
#citation("RPostgreSQL")
#citation("RColorBrewer")
#citation("plyr")
#citation("ggplot2")
#citation("stargazer")
#citation("visreg")
#citation("mgcv")
#citation("PresenceAbsence")
graphics.off()
#options(warn =  -1)
options(sqldf.RPostgreSQL.user = "postgres",
sqldf.RPostgreSQL.password = passwordlocal,
sqldf.RPostgreSQL.dbname = "eda2.3",
sqldf.RPostgreSQL.host = "localhost",#  1.100.1.6
sqldf.RPostgreSQL.port = 5432)
#t <- tryCatch(sqldf("select gid from rht.rhtvs2 limit 1"),error =  function(e) e)
#is_simple_error <- function(x) inherits(x, "simpleError")
#if (is_simple_error(t)) stop("distant call using w3.eptb-vilaine.fr failed, check connection to the database")
datawd<-"C:/workspace/EDAdata/"
ddatawd <- "C:/workspace/EDAdata/report2.3/data/"
imgwd<-"C:/workspace/EDAdata/report2.3/images/"
shpwd="C:/workspace/EDAdata/dataEDAlb2/shp/"
edawd="C:/workspace/EDA/"
# Attention il faut creer les repertoires
options(warn =  0)
#setwd("C:/workspace/EDA/report2.3")
#datawd <- "C:/workspace/EDAdata/"
ddatawd <- paste0(datawd,"/report2.3/data/")
#imgwd <- "C:/workspace/EDAdata/reportt2.3/images/"
#edawd =  "C:/workspace/EDA/"
sanitizeLatexS <- function(str) {
gsub('([#$%&~_\\^\\\\{}])', '\\\\\\\\\\1', str, perl = TRUE);
}
# la fonction sn utilise maintenant le package siunitx
# ajouter \usepackage{siunitx}
#\sisetup{
#round-mode = places, % nombre de decimales apres la virgule
#round-precision = 3
#}%
# Dans le preambule
num <- function(x,round_precision =  NULL)
{
if (is.null(round_precision)) {
return(sprintf("\\num{%s}", x))
} else {
return(sprintf("\\num[round-precision=%s]{%s}",round_precision+1, x))
}
}
wd <- getwd()
# choix de la version a charger
rapport <- "2020" #"2012" "2015" "2009" donnees celine
sector <- "spain"
open_in_excel <- function(some_df){
tFile <- paste("C:/temp/",gsub("\\\\","",tempfile(fileext =  paste0(substitute(some_df), ".csv"),tmpdir =  "")),sep =  "")
write.table(some_df, tFile, row.names = F, sep = ";", quote = F)
system(paste('open -a \"/ProgramData/Microsoft/Windows/Start Menu/Programs/Microsoft Office/Microsoft Excel 2010\"', tFile))
}
library(sf)
require(RPostgreSQL)
require(sqldf)
require(kableExtra)
require(tidyr)
blue_s <- "#00B8CD"
orange_s <- "#DB6118"
navy_s <- "#164193"
green_s <- "#95C300"
#Trying to reproduce excactly the results of Antoine Martelet report.
# Martelet 2019 - Mise à jour des diagnostics de mortalité pour des anguilles dévalant au droit de centrales
# hydroélectriques
load(file=str_c(ddatawd,"turb_rios.Rdata"))
# Migration equal between Q75 Q90 Q95 Q975 and Q99 as in Martelet report --------
tmigration_flow <- read.table(text="q_1004_75 q_1004_90 q_1004_95 q_1004_975 q_1004_99
0.2	0.2	0.2	0.2	0.2", header= TRUE)
# only select values from the upper Gave de Pau ---------------------------------
con=dbConnect(PostgreSQL(),
dbname="eda2.3",
host="localhost",
port=5432,
user= userlocal,
password= passwordlocal)
# Subsetting data to only get the downstream part of Gave de Pau
# downstream segment vector from the upper reach of Gave de Pau
gave_de_Pau <- dbGetQuery(con, "select dbeel_rivers.downstream_segments_rn('FR123495')")[,1]
# Using this segment to subset the tables in cascade
turb_rios_m <- turb_rios # (turb rios martelet)
turb_rios_m@tablehppdbeel <- subset(
turb_rios_m@tablehppdbeel,
turb_rios_m@tablehppdbeel$idsegment %in% gave_de_Pau)
#nrow(turb_rios_m@tablehppdbeel) # 42
turb_rios_m@tablemortalityturbine <- subset(
turb_rios_m@tablemortalityturbine,
turb_rios_m@tablemortalityturbine$hpp_id %in% turb_rios_m@tablehppdbeel$hpp_id)
#nrow(turb_rios_m@tablemortalityturbine) # 45
turb_rios_m@tablemortalitydam <- subset(turb_rios_m@tablemortalitydam,
turb_rios_m@tablemortalitydam$op_id_pere %in% turb_rios_m@tablehppdbeel$op_id)
# nrow(turb_rios_m@tablemortalitydam) # 18
turb_rios_m@tableturbinedbeel <- subset(
turb_rios_m@tableturbinedbeel,
turb_rios_m@tableturbinedbeel$turb_hpp_id %in% turb_rios_m@tablehppdbeel$hpp_id)
# nrow(turb_rios_m@tableturbinedbeel) # 45
# reserved flow to 0.1 (TODO check if Antoine used that)----------------------
turb_rios_m@tablemortalitydam$prop_preserve <- rep(0.1, nrow(turb_rios_m@tablemortalitydam))
# calculate within turbines mortalities with the same assumption than martelet--------
# size 0.5 0.7 0.9 with equal proportions
# proportions 1/3 1/3 1/3
hpp_turb <- inner_join(turb_rios_m@tablehppdbeel,
turb_rios_m@tableturbinedbeel,
by=c("hpp_id"="turb_hpp_id")) #45
#  Step 1 calculate mortality in the turbines --------------
# this one is just used to get the right number of lines.....
turb_rios_m <- turbine_mortality (turb_rios_m,
size_table_eel= matrix(1/3,nrow=nrow(hpp_turb),ncol=3),
middle_class_eel = c(0.50,0.70,0.90)
)
turb_rios_m@tablemortalitydam$prop_preserve <- rep(0.1, nrow(turb_rios_m@tablemortalitydam))
turb_gave_m <- segment_mortality(turb_rios_m,
seaidsegment = 'FR118671',
migrationflow=tmigration_flow[1,])
tmigration_flow <- read.table(text="loc q_1004_75 q_1004_90 q_1004_95 q_1004_975 q_1004_99
gave 0.2	0.2	0.2	0.2	0.2", header= TRUE)
turb_gave_m <- segment_mortality(turb_rios_m,
seaidsegment = 'FR118671',
migrationflow=tmigration_flow[1,])
tmigration_flow
migrationflow=tmigration_flow[1,]
seaidsegment = 'FR118671'
#Trying to reproduce excactly the results of Antoine Martelet report.
# Martelet 2019 - Mise à jour des diagnostics de mortalité pour des anguilles dévalant au droit de centrales
# hydroélectriques
load(file=str_c(ddatawd,"turb_rios.Rdata"))
# Migration equal between Q75 Q90 Q95 Q975 and Q99 as in Martelet report --------
tmigration_flow <- read.table(text="loc q_1004_75 q_1004_90 q_1004_95 q_1004_975 q_1004_99
gave	0.2	0.2		0.2	0.2	0.2", header= TRUE)
# only select values from the upper Gave de Pau ---------------------------------
con=dbConnect(PostgreSQL(),
dbname="eda2.3",
host="localhost",
port=5432,
user= userlocal,
password= passwordlocal)
# Subsetting data to only get the downstream part of Gave de Pau
# downstream segment vector from the upper reach of Gave de Pau
gave_de_Pau <- dbGetQuery(con, "select dbeel_rivers.downstream_segments_rn('FR123495')")[,1]
# Using this segment to subset the tables in cascade
turb_rios_m <- turb_rios # (turb rios martelet)
turb_rios_m@tablehppdbeel <- subset(
turb_rios_m@tablehppdbeel,
turb_rios_m@tablehppdbeel$idsegment %in% gave_de_Pau)
#nrow(turb_rios_m@tablehppdbeel) # 42
turb_rios_m@tablemortalityturbine <- subset(
turb_rios_m@tablemortalityturbine,
turb_rios_m@tablemortalityturbine$hpp_id %in% turb_rios_m@tablehppdbeel$hpp_id)
#nrow(turb_rios_m@tablemortalityturbine) # 45
turb_rios_m@tablemortalitydam <- subset(turb_rios_m@tablemortalitydam,
turb_rios_m@tablemortalitydam$op_id_pere %in% turb_rios_m@tablehppdbeel$op_id)
# nrow(turb_rios_m@tablemortalitydam) # 18
turb_rios_m@tableturbinedbeel <- subset(
turb_rios_m@tableturbinedbeel,
turb_rios_m@tableturbinedbeel$turb_hpp_id %in% turb_rios_m@tablehppdbeel$hpp_id)
# nrow(turb_rios_m@tableturbinedbeel) # 45
# reserved flow to 0.1 (TODO check if Antoine used that)----------------------
turb_rios_m@tablemortalitydam$prop_preserve <- rep(0.1, nrow(turb_rios_m@tablemortalitydam))
# calculate within turbines mortalities with the same assumption than martelet--------
# size 0.5 0.7 0.9 with equal proportions
# proportions 1/3 1/3 1/3
hpp_turb <- inner_join(turb_rios_m@tablehppdbeel,
turb_rios_m@tableturbinedbeel,
by=c("hpp_id"="turb_hpp_id")) #45
#  Step 1 calculate mortality in the turbines --------------
# this one is just used to get the right number of lines.....
turb_rios_m <- turbine_mortality (turb_rios_m,
size_table_eel= matrix(1/3,nrow=nrow(hpp_turb),ncol=3),
middle_class_eel = c(0.50,0.70,0.90)
)
turb_rios_m@tablemortalitydam$prop_preserve <- rep(0.1, nrow(turb_rios_m@tablemortalitydam))
turb_gave_m <- segment_mortality(turb_rios_m,
seaidsegment = 'FR118671',
migrationflow=tmigration_flow[1,])
table_hpp <-
left_join(
turb_gave_m@tablehppdbeel %>%
filter(is.na(op_op_id)) %>%
select("op_id", "op_placename", "id_original",  "ob_id",   "po_obstruction_height",
"po_downs_pb", "po_downs_water_depth", "date_last_update", "author_last_update",
"comment_update", "mitigation_measure_no_id",
"hpp_id", "hpp_name", "hpp_main_grid_or_production", "hpp_presence_bypass",
"hpp_total_flow_bypass", "hpp_orient_flow_no_id", "hpp_presence_of_bar_rack",
"hpp_bar_rack_space", "hpp_surface_bar_rack",
"hpp_inclination_bar_rack", "hpp_presence_bypass_trashrack", "hpp_nb_trashrack_bypass",
"hpp_turb_max_flow", "hpp_reserved_flow", "hpp_flow_trashrack_bypass", "hpp_max_power",
"hpp_orientation_bar_rack", "hpp_id_original", "hpp_source", "googlemapscoods",
"idsegment", "cnfemale300450", "cnfemale450600", "cnfemale600750", "cnfemale750",
"cnmale150300", "cnmale300450", "cnmale450600", "cnsilver150300", "cnsilver300450",
"cnsilver450600", "cnsilver600750", "cnsilver750", "cnsilver",
"code_hydro_station", "station_idsegment", "station_q50", "station_source_flow", "station_surfacebvm2",
"idsegment_q50", "idsegment_source_flow", "idsegment_surfacebvm2"),
turb_gave_m@tablemortalitydam %>% select (
c("op_id_pere", "mortality_eel", "mortality_smolt",
"q_equipment_dam", "prop_preserve",
"segment_q_1004_75", "segment_q_1004_90", "segment_q_1004_95", "segment_q_1004_975",
"segment_q_1004_99",
"mortality_q_1004_75",
"mortality_q_1004_90", "mortality_q_1004_95", "mortality_q_1004_975","mortality_q_1004_99",
"production_upstream",
"net_production_upstream",
"net_survival_q_1004_75", "net_survival_q_1004_90", "net_survival_q_1004_95",
"net_survival_q_1004_975", "net_survival_q_1004_99",
"pot_nb_killed_q_1004_75",
"pot_nb_killed_q_1004_90", "pot_nb_killed_q_1004_95", "pot_nb_killed_q_1004_975", "pot_nb_killed_q_1004_99",
"net_nb_killed",
"potential_nb_killed",
"mort_rate" )),
by=c("op_id"="op_id_pere"))
(nr1 <- nrow(table_hpp)) # 243
table_hpp1 <- table_hpp %>%
arrange(idsegment_q50) %>%
select ("op_placename", "id_original","mort_rate","net_nb_killed",
"potential_nb_killed") %>%
mutate(op_placename=iconv(op_placename, to = "UTF-8"))%>%
filter(!is.na(mort_rate))
table_hpp1 %>%
kable(caption = "Test") %>%
kable_paper(full_width = F)  %>%
column_spec(3, color = "white",
background = spec_color(table_hpp1$mort_rate, end = 1)
) %>%
column_spec(4, color = "white",
background = spec_color(table_hpp1$potential_nb_killed, option= "E", end = 1)
) %>%
column_spec(5, color = "white",
background = spec_color(table_hpp1$potential_nb_killed, option= "E", end = 1)
)
table_hpp1
table_hpp1 <- table_hpp %>%
arrange(idsegment_q50) %>%
select ("op_placename", "id_original","mort_rate","net_nb_killed",
"potential_nb_killed") %>%
mutate(op_placename=iconv(op_placename, from = 'WIN1252', to = "UTF-8"))%>%
filter(!is.na(mort_rate))
? iconv
table_hpp1 <- table_hpp %>%
arrange(idsegment_q50) %>%
select ("op_placename", "id_original","mort_rate","net_nb_killed",
"potential_nb_killed") %>%
mutate(op_placename=iconv(op_placename, from = "latin1", to = "UTF-8"))%>%
filter(!is.na(mort_rate))
table_hpp1
table_hpp1 <- table_hpp %>%
arrange(idsegment_q50) %>%
select ("op_placename", "id_original","mort_rate","net_nb_killed",
"potential_nb_killed") %>%
mutate(op_placename=iconv(op_placename, from = "UTF-8", to = "latin1"))%>%
filter(!is.na(mort_rate))
table_hpp1
sessionInfo()
install.packages(c("rj", "rj.gd"), repos="https://download.walware.de/rj-4.0")
setwd("C:/workspace/tools4DCE")
library(tools4DCE)
filtre_donnees_extremes(seq(1:10), ymin=3, ymax=9)
? trim
